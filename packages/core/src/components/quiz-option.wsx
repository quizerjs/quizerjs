/** @jsxImportSource @wsxjs/wsx-core */
/**
 * 单个选项组件
 * 用于 Editor.js 工具中编辑单个选项
 * 支持编辑选项文本、设置正确答案、删除选项
 */

import { LightComponent, autoRegister, state } from '@wsxjs/wsx-core';
import { QuestionTypes, type QuestionType } from '@quizerjs/dsl';
import styles from './quiz-option.css?inline';

interface QuizOptionProps {
  /** 选项 ID */
  optionId?: string;
  /** 选项文本（HTML 格式） */
  text?: string;
  /** 是否选中（作为正确答案） */
  selected?: string | boolean;
  /** 选项类型 */
  type?: typeof QuestionTypes.SINGLE_CHOICE | typeof QuestionTypes.MULTIPLE_CHOICE;
  /** 是否只读模式 */
  readonly?: string | boolean;
}

@autoRegister({ tagName: 'quiz-option' })
export class QuizOption extends LightComponent {
  // 响应式状态 - 使用 @state 装饰器
  @state private optionId = '';
  @state private text = '';
  @state private selected = false;
  @state private type: typeof QuestionTypes.SINGLE_CHOICE | typeof QuestionTypes.MULTIPLE_CHOICE =
    QuestionTypes.SINGLE_CHOICE;
  @state private readonly = false;

  private textElement: HTMLElement | null = null;

  constructor() {
    super({
      styles,
      styleName: 'quiz-option',
    });
  }

  static get observedAttributes() {
    return ['optionid', 'text', 'selected', 'type', 'readonly'];
  }

  protected onAttributeChanged(name: string, _oldValue: string, newValue: string) {
    switch (name) {
      case 'optionid':
        this.optionId = newValue || '';
        break;
      case 'text':
        // 更新 text 状态（用于初始渲染），但不触发重新渲染
        this.text = newValue || '';
        // 如果 textElement 已存在且没有焦点，更新 DOM
        if (this.textElement && document.activeElement !== this.textElement) {
          if (this.textElement.innerHTML !== newValue) {
            this.textElement.innerHTML = newValue || '';
          }
        }
        break;
      case 'selected':
        this.selected = newValue === 'true';
        break;
      case 'type':
        this.type =
          (newValue as typeof QuestionTypes.SINGLE_CHOICE | typeof QuestionTypes.MULTIPLE_CHOICE) ||
          QuestionTypes.SINGLE_CHOICE;
        break;
      case 'readonly':
        this.readonly = newValue === 'true';
        this.setupTextElement();
        break;
    }
  }

  onConnected() {
    this.setupTextElement();
    // 如果 text 属性存在但 textElement 还没有内容，设置初始文本
    if (this.textElement && this.text && !this.textElement.innerHTML) {
      this.textElement.innerHTML = this.text;
    }
  }

  onDisconnected() {
    // 清理事件监听器
    if (this.textElement) {
      this.textElement.removeEventListener('input', this.handleInput);
    }
  }

  private setupTextElement() {
    if (!this.textElement) return;

    const isReadonly = this.readonly;

    // 显式设置 contentEditable（与 quiz-question-header 保持一致）
    // 这确保了即使组件重新渲染，contentEditable 也会被正确设置
    this.textElement.contentEditable = isReadonly ? 'false' : 'true';
    this.textElement.setAttribute('spellcheck', 'true');

    // 清理旧的事件监听器
    this.textElement.removeEventListener('input', this.handleInput);

    // 只在非只读模式下添加事件监听器
    if (!isReadonly) {
      // 使用 input 事件监听任何变化，不需要 blur 事件
      // 因为不会重新渲染，所以可以实时更新值
      this.textElement.addEventListener('input', this.handleInput);
    }
  }

  private handleInput = () => {
    if (this.textElement) {
      const html = this.textElement.innerHTML;
      // 不更新 text 状态，避免重新渲染
      // 直接派发 textchange 事件，实时更新父组件的值
      this.dispatchEvent(
        new CustomEvent('textchange', {
          detail: { optionId: this.optionId, text: html },
          bubbles: true,
        })
      );
    }
  };

  private handleSelect = () => {
    const isReadonly = this.readonly;
    if (isReadonly) return;

    const newSelected = !this.selected;
    this.selected = newSelected;
    this.dispatchEvent(
      new CustomEvent('select', {
        detail: { optionId: this.optionId, selected: newSelected },
        bubbles: true,
      })
    );
  };

  private handleDelete = () => {
    const isReadonly = this.readonly;
    if (isReadonly) return;

    this.dispatchEvent(
      new CustomEvent('delete', {
        detail: { optionId: this.optionId },
        bubbles: true,
      })
    );
  };

  /**
   * 获取选项文本（HTML 格式）
   */
  getText(): string {
    return this.textElement?.innerHTML || '';
  }

  /**
   * 设置选项文本（HTML 格式）
   */
  setText(html: string): void {
    if (this.textElement) {
      this.textElement.innerHTML = html;
    }
  }

  /**
   * 获取选项数据
   */
  getData(): { id: string; text: string; isCorrect: boolean } {
    return {
      id: this.optionId,
      text: this.getText(),
      isCorrect: this.selected,
    };
  }

  render() {
    const isReadonly = this.readonly;
    const isSelected = this.selected;
    const currentType = this.type;
    const inputType = currentType === QuestionTypes.SINGLE_CHOICE ? 'radio' : 'checkbox';
    // 只在初始渲染时使用 text 状态，之后由 contentEditable 维护
    // 使用 optionid 作为 key 的一部分，确保组件在选项变化时正确更新
    const initialText = this.text;

    const classNames = ['quiz-option'];
    if (isSelected) classNames.push('quiz-option-selected');
    if (isReadonly) classNames.push('quiz-option-readonly');

    return (
      <div className={classNames.join(' ')}>
        <input
          type={inputType}
          className={
            currentType === QuestionTypes.SINGLE_CHOICE
              ? 'quiz-option-radio'
              : 'quiz-option-checkbox'
          }
          checked={isSelected}
          disabled={isReadonly}
          onChange={this.handleSelect}
        />
        <div
          className="quiz-option-text"
          innerHTML={initialText}
          contentEditable={!isReadonly}
          ref={el => {
            if (el && el !== this.textElement) {
              // 清理旧元素的事件监听器
              if (this.textElement) {
                this.textElement.removeEventListener('input', this.handleInput);
              }
              // 保存引用
              this.textElement = el;
              // 初始化内容：如果元素为空或内容与 initialText 不同，则设置
              const currentContent = el.innerHTML.trim();
              const textToSet = initialText || '';
              if (!currentContent || currentContent !== textToSet) {
                el.innerHTML = textToSet;
              }
              // 设置事件监听器
              this.setupTextElement();
            }
          }}
        />
        {!isReadonly && (
          <div className="quiz-option-actions">
            <button className="quiz-option-button" onClick={this.handleDelete} type="button">
              删除
            </button>
          </div>
        )}
      </div>
    );
  }
}
