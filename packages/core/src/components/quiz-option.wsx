/** @jsxImportSource @wsxjs/wsx-core */
/**
 * 单个选项组件
 * 用于 Editor.js 工具中编辑单个选项
 * 支持编辑选项文本、设置正确答案、删除选项
 */

import { LightComponent, autoRegister } from '@wsxjs/wsx-core';
import { QuestionType } from '@quizerjs/dsl';
import styles from './quiz-option.css?inline';

interface QuizOptionProps {
  /** 选项 ID */
  optionId?: string;
  /** 选项文本（HTML 格式） */
  text?: string;
  /** 是否选中（作为正确答案） */
  selected?: string | boolean;
  /** 选项类型 */
  type?: QuestionType.SINGLE_CHOICE | QuestionType.MULTIPLE_CHOICE;
  /** 是否只读模式 */
  readonly?: string | boolean;
}

@autoRegister({ tagName: 'quiz-option' })
export class QuizOption extends LightComponent {
  // 响应式状态
  private optionIdState = this.useState('optionId', '');
  private textState = this.useState('text', '');
  private selectedState = this.useState('selected', false);
  private typeState = this.useState('type', QuestionType.SINGLE_CHOICE);
  private readonlyState = this.useState('readonly', false);

  // Getter/setter
  private optionId = () => this.optionIdState[0]();
  private setOptionId = (value: string) => this.optionIdState[1](value);
  private text = () => this.textState[0]();
  private setTextState = (value: string) => this.textState[1](value);
  private selected = () => this.selectedState[0]();
  private setSelected = (value: boolean) => this.selectedState[1](value);
  private type = () => this.typeState[0]();
  private setType = (value: QuestionType.SINGLE_CHOICE | QuestionType.MULTIPLE_CHOICE) =>
    this.typeState[1](value);
  private readonly = () => this.readonlyState[0]();
  private setReadonly = (value: boolean) => this.readonlyState[1](value);

  private textElement: HTMLElement | null = null;

  constructor() {
    super({
      styles,
      styleName: 'quiz-option',
    });
  }

  static get observedAttributes() {
    return ['optionid', 'text', 'selected', 'type', 'readonly'];
  }

  protected onAttributeChanged(name: string, _oldValue: string, newValue: string) {
    switch (name) {
      case 'optionid':
        this.setOptionId(newValue || '');
        break;
      case 'text':
        this.setTextState(newValue || '');
        break;
      case 'selected':
        this.setSelected(newValue === 'true');
        break;
      case 'type':
        this.setType(
          (newValue as QuestionType.SINGLE_CHOICE | QuestionType.MULTIPLE_CHOICE) ||
            QuestionType.SINGLE_CHOICE
        );
        break;
      case 'readonly':
        this.setReadonly(newValue === 'true');
        break;
    }
  }

  connectedCallback() {
    super.connectedCallback();
    this.setupTextElement();
  }

  private setupTextElement() {
    if (!this.textElement) return;

    const isReadonly = this.readonly();

    // 设置 contentEditable
    this.textElement.contentEditable = isReadonly ? 'false' : 'true';

    // 监听输入变化
    if (!isReadonly) {
      this.textElement.addEventListener('input', this.handleInput);
      this.textElement.addEventListener('blur', this.handleBlur);
    }
  }

  private handleInput = (e: Event) => {
    const target = e.target as HTMLElement;
    const html = target.innerHTML;
    this.setTextState(html);
    this.dispatchEvent(
      new CustomEvent('textchange', {
        detail: { optionId: this.optionId(), text: html },
        bubbles: true,
      })
    );
  };

  private handleBlur = () => {
    if (this.textElement) {
      const html = this.textElement.innerHTML;
      this.setTextState(html);
      this.dispatchEvent(
        new CustomEvent('textblur', {
          detail: { optionId: this.optionId(), text: html },
          bubbles: true,
        })
      );
    }
  };

  private handleSelect = () => {
    const isReadonly = this.readonly();
    if (isReadonly) return;

    const newSelected = !this.selected();
    this.setSelected(newSelected);
    this.dispatchEvent(
      new CustomEvent('select', {
        detail: { optionId: this.optionId(), selected: newSelected },
        bubbles: true,
      })
    );
  };

  private handleDelete = () => {
    const isReadonly = this.readonly();
    if (isReadonly) return;

    this.dispatchEvent(
      new CustomEvent('delete', {
        detail: { optionId: this.optionId() },
        bubbles: true,
      })
    );
  };

  /**
   * 获取选项文本（HTML 格式）
   */
  getText(): string {
    return this.textElement?.innerHTML || '';
  }

  /**
   * 设置选项文本（HTML 格式）
   */
  setText(html: string): void {
    if (this.textElement) {
      this.textElement.innerHTML = html;
    }
  }

  /**
   * 获取选项数据
   */
  getData(): { id: string; text: string; isCorrect: boolean } {
    return {
      id: this.optionId(),
      text: this.getText(),
      isCorrect: this.selected(),
    };
  }

  render() {
    const isReadonly = this.readonly();
    const isSelected = this.selected();
    const currentType = this.type();
    const inputType = currentType === QuestionType.SINGLE_CHOICE ? 'radio' : 'checkbox';

    const classNames = ['quiz-option'];
    if (isSelected) classNames.push('quiz-option-selected');
    if (isReadonly) classNames.push('quiz-option-readonly');

    return (
      <div className={classNames.join(' ')}>
        <input
          type={inputType}
          className={
            currentType === QuestionType.SINGLE_CHOICE
              ? 'quiz-option-radio'
              : 'quiz-option-checkbox'
          }
          checked={isSelected}
          disabled={isReadonly}
          onChange={this.handleSelect}
        />
        <div
          className="quiz-option-text"
          ref={el => {
            this.textElement = el;
            this.setupTextElement();
          }}
          innerHTML={this.text()}
          contentEditable={!isReadonly}
        />
        {!isReadonly && (
          <div className="quiz-option-actions">
            <button className="quiz-option-button" onClick={this.handleDelete} type="button">
              删除
            </button>
          </div>
        )}
      </div>
    );
  }
}
