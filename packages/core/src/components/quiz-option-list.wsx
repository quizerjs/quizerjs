/** @jsxImportSource @wsxjs/wsx-core */
/**
 * 选项列表组件
 * 用于 Editor.js 工具中管理选项列表
 * 支持添加、删除、重新排序选项
 *
 * 渲染优化（RFC 0007）：
 * - 使用 itemsState（响应式）用于渲染，只在添加/删除时更新
 * - 使用 valuesMap（非响应式）存储文本值，更新时不触发渲染
 * - 文本改变只更新 valuesMap，不触发重新渲染，避免焦点丢失
 */

import { LightComponent, autoRegister, state } from '@wsxjs/wsx-core';
import { QuestionTypes, type QuestionType } from '@quizerjs/dsl';
import type { Option } from '@quizerjs/dsl';
// WSX 组件自动注册，无需手动注册
import './quiz-option.wsx';
import styles from './quiz-option-list.css?inline';

@autoRegister({ tagName: 'quiz-option-list' })
export class QuizOptionList extends LightComponent {
  // 响应式状态 - 用于渲染的选项数组（只在添加/删除时更新）
  @state private items: Option[] = [];
  @state private type: typeof QuestionTypes.SINGLE_CHOICE | typeof QuestionTypes.MULTIPLE_CHOICE =
    QuestionTypes.SINGLE_CHOICE;
  @state private readonly = false;

  // 非响应式状态 - 存储选项文本值的 Map（更新时不触发渲染）
  private valuesMap = new Map<string, string>();

  // 添加选项按钮的引用
  private addButtonRef: HTMLButtonElement | null = null;

  constructor() {
    super({
      styles,
      styleName: 'quiz-option-list',
    });
  }

  static get observedAttributes() {
    return ['options', 'type', 'readonly'];
  }

  protected onAttributeChanged(name: string, _oldValue: string, newValue: string) {
    switch (name) {
      case 'options':
        const options = JSON.parse(newValue || '[]');
        const parsedOptions = Array.isArray(options) ? options : [];

        // 比较新旧选项 ID，只在添加/删除时更新
        const currentIds = new Set(this.items.map(item => item.id));
        const newIds = new Set(parsedOptions.map(opt => opt.id));
        const idsChanged =
          currentIds.size !== newIds.size || [...newIds].some(id => !currentIds.has(id));

        if (idsChanged) {
          // ID 变化：更新 items，触发渲染
          this.items = parsedOptions;
          // 重建 valuesMap
          this.valuesMap.clear();
          parsedOptions.forEach(opt => {
            if (opt.text) {
              this.valuesMap.set(opt.id, opt.text);
            }
          });
        }
        // 如果只是内容变化（如 isCorrect），不更新 items，不触发渲染
        break;
      case 'type':
        this.type =
          (newValue as typeof QuestionTypes.SINGLE_CHOICE | typeof QuestionTypes.MULTIPLE_CHOICE) ||
          QuestionTypes.SINGLE_CHOICE;
        break;
      case 'readonly':
        this.readonly = newValue === 'true';
        break;
    }
  }

  private generateOptionId(): string {
    return `opt-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * 派发 optionschange 事件
   */
  private dispatchOptionsChange(): void {
    this.dispatchEvent(
      new CustomEvent('optionschange', {
        detail: { options: this.getOptions() },
        bubbles: true,
        composed: true,
      })
    );
  }

  private handleAddOption = () => {
    console.log('[quiz-option-list] handleAddOption called');

    const isReadonly = this.readonly;
    if (isReadonly) {
      return;
    }

    // 先合并 items 和 valuesMap（使用追踪的文本值），确保数据一致性
    const mergedItems = this.mergeItemsAndValues();
    console.log('[quiz-option-list] mergedItems:', JSON.stringify(mergedItems));

    const newOption: Option = {
      id: this.generateOptionId(),
      text: '',
      isCorrect: false,
    };

    // 创建新数组引用，确保 @state 能检测到变化
    const newItems = [...mergedItems, newOption];

    // 更新响应式状态，触发渲染
    this.items = newItems;

    // 派发 optionschange 事件，通知 Editor.js 有变化
    this.dispatchOptionsChange();
  };

  private handleOptionSelect = (e: CustomEvent) => {
    const { optionId, selected } = e.detail;
    const currentItems = this.items;
    const option = currentItems.find(opt => opt.id === optionId);
    if (!option) return;

    const currentType = this.type;

    // 合并 items 和 valuesMap（使用追踪的文本值）
    const mergedItems = this.mergeItemsAndValues();

    let updatedItems: Option[];
    if (currentType === QuestionTypes.SINGLE_CHOICE) {
      // 单选题：只能选择一个
      updatedItems = mergedItems.map(opt => ({
        ...opt,
        isCorrect: opt.id === optionId && selected,
      }));
    } else {
      // 多选题：可以多选
      updatedItems = mergedItems.map(opt =>
        opt.id === optionId ? { ...opt, isCorrect: selected } : opt
      );
    }

    // 更新响应式状态，触发渲染
    this.items = updatedItems;
    // 派发 optionschange 事件，通知 Editor.js 有变化
    this.dispatchOptionsChange();
  };

  private handleOptionTextChange = (e: CustomEvent) => {
    const { optionId, text } = e.detail;
    // 只更新 valuesMap（非响应式），不触发重新渲染
    // 不派发事件，避免触发 Editor.js 重新渲染
    // 最新值会在 save() 时通过 getOptions() 获取
    this.valuesMap.set(optionId, text);
  };

  private handleOptionDelete = (e: CustomEvent) => {
    const { optionId } = e.detail;
    // 先合并 items 和 valuesMap（使用追踪的文本值），确保数据一致性
    const mergedItems = this.mergeItemsAndValues();
    // 从 valuesMap 中移除
    this.valuesMap.delete(optionId);
    // 过滤删除的选项
    const filteredItems = mergedItems.filter(opt => opt.id !== optionId);
    // 更新响应式状态，触发渲染
    this.items = filteredItems;
    // 派发 optionschange 事件，通知 Editor.js 有变化
    this.dispatchOptionsChange();
  };

  /**
   * 合并 items 和 values，生成完整的选项列表
   * 用于在添加/删除时确保数据一致性
   */
  private mergeItemsAndValues(): Option[] {
    return this.items.map(item => ({
      ...item,
      text: this.valuesMap.get(item.id) ?? item.text,
    }));
  }

  /**
   * 获取选项列表（合并 items 和 values）
   * 用于保存和外部访问
   */
  getOptions(): Option[] {
    return this.mergeItemsAndValues();
  }

  /**
   * 设置选项列表
   */
  setOptionsList(options: Option[]): void {
    // 更新 items（用于渲染）
    this.items = [...options];
    // 同步更新 valuesMap
    this.valuesMap.clear();
    options.forEach(opt => {
      if (opt.text) {
        this.valuesMap.set(opt.id, opt.text);
      }
    });
    this.dispatchOptionsChange();
  }

  onConnected() {
    // 先移除旧的监听器（如果存在），防止重复注册
    this.removeEventListener('select', this.handleOptionSelect as EventListener);
    this.removeEventListener('textchange', this.handleOptionTextChange as EventListener);
    this.removeEventListener('delete', this.handleOptionDelete as EventListener);
    // 监听 blur 事件 (通过 focusout 捕获冒泡)
    this.removeEventListener('focusout', this.handleBlur as EventListener);

    // 监听子组件事件
    this.addEventListener('select', this.handleOptionSelect as EventListener);
    this.addEventListener('textchange', this.handleOptionTextChange as EventListener);
    this.addEventListener('delete', this.handleOptionDelete as EventListener);
    // 监听 focusout 事件以处理失焦保存
    this.addEventListener('focusout', this.handleBlur as EventListener);
  }

  onDisconnected() {
    // 清理添加选项按钮的事件监听器
    if (this.addButtonRef) {
      this.addButtonRef.removeEventListener('click', this.handleAddOption);
    }
    // 移除所有事件监听器
    this.removeEventListener('select', this.handleOptionSelect as EventListener);
    this.removeEventListener('textchange', this.handleOptionTextChange as EventListener);
    this.removeEventListener('delete', this.handleOptionDelete as EventListener);
    this.removeEventListener('focusout', this.handleBlur as EventListener);
  }

  private handleBlur = (e: FocusEvent) => {
    // 当焦点离开选项列表或其子元素时触发
    // 使用 setTimeout 确保在焦点切换完成后执行，并检查新焦点是否仍在组件内
    setTimeout(() => {
      const newActiveElement = document.activeElement;
      // 如果新焦点不在当前组件内，说明是真的失焦（这就是我们想保存的时候）
      // 或者如果只是在组件内部切换焦点（比如从一个选项到另一个），也可以选择保存，
      // 但为了性能，我们主要关心"完成编辑"的时刻。
      // 不过，为了最安全的数据同步，只要有 focusout 就同步一次也是可以的，
      // 因为 valuesMap 已经是最新的了。

      // 简单起见，且为了确保"打字后点击添加选项"也能保存前一个选项的文本：
      // 这里的 blur 主要是为了触发 save/dispatchChange
      this.dispatchOptionsChange();
    }, 0);
  };

  render() {
    const isReadonly = this.readonly;
    const currentType = this.type;
    // 使用 items（用于渲染），只在添加/删除时更新
    // quiz-option 组件通过 contentEditable 维护实际文本值
    const currentItems = this.items;

    return (
      <div className="quiz-option-list">
        <div className="quiz-option-list-header">
          <div className="quiz-option-list-title">选项</div>
          {!isReadonly && (
            <button
              className="quiz-option-list-add-button"
              type="button"
              ref={(el: HTMLElement) => {
                // 清理旧的事件监听器
                if (this.addButtonRef) {
                  this.addButtonRef.removeEventListener('click', this.handleAddOption);
                }
                // 保存引用并添加事件监听器
                this.addButtonRef = el as HTMLButtonElement;
                if (el) {
                  el.addEventListener('click', this.handleAddOption);
                }
              }}
            >
              + 添加选项
            </button>
          )}
        </div>
        <div className="quiz-option-list-items">
          {currentItems.length === 0 ? (
            <div className="quiz-option-list-empty">暂无选项，点击"添加选项"开始</div>
          ) : (
            currentItems.map(option => (
              <quiz-option
                key={option.id}
                optionid={option.id}
                // 使用 item 的 text（初始值），实际文本由 quiz-option 的 contentEditable 维护
                text={option.text}
                selected={option.isCorrect ? 'true' : 'false'}
                type={currentType}
                readonly={isReadonly ? 'true' : 'false'}
                ontextchange={(e: CustomEvent) => this.handleOptionTextChange(e)}
                onselect={(e: CustomEvent) => this.handleOptionSelect(e)}
                ondelete={(e: CustomEvent) => this.handleOptionDelete(e)}
              />
            ))
          )}
        </div>
      </div>
    );
  }
}
