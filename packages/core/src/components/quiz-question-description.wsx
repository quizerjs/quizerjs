/** @jsxImportSource @wsxjs/wsx-core */
/**
 * 问题描述组件
 * 用于 Editor.js 工具中编辑问题描述
 * 支持 contentEditable 和 Editor.js inline tools
 */

import { LightComponent, autoRegister, state } from '@wsxjs/wsx-core';
import styles from './quiz-question-description.css?inline';
import { L10nService } from '../l10n';

@autoRegister({ tagName: 'quiz-question-description' })
export class QuizQuestionDescription extends LightComponent {
  // 响应式状态 - 使用 @state 装饰器
  private text = ''; // 不再使用 @state
  @state private readonly = false;

  private editableElement: HTMLElement | null = null;

  constructor() {
    super({
      styles,
      styleName: 'quiz-question-description',
    });
  }

  static get observedAttributes() {
    return ['text', 'readonly'];
  }

  protected onAttributeChanged(name: string, _oldValue: string, newValue: string) {
    switch (name) {
      case 'text':
        this.text = newValue || '';
        // 外部属性更新时，如果不是焦点，同步 DOM
        if (this.editableElement && document.activeElement !== this.editableElement) {
          if (this.editableElement.innerHTML !== this.text) {
            this.editableElement.innerHTML = this.text;
          }
        }
        break;
      case 'readonly':
        this.readonly = newValue === 'true';
        this.setupEditableElement();
        break;
    }
  }

  onConnected() {
    this.setupEditableElement();
  }

  onDisconnected() {
    // 清理事件监听器
    if (this.editableElement) {
      this.editableElement.removeEventListener('input', this.handleInput);
    }
  }

  private setupEditableElement() {
    if (!this.editableElement) return;

    const isReadonly = this.readonly;

    // 设置 contentEditable
    this.editableElement.contentEditable = isReadonly ? 'false' : 'true';

    // 如果已经有 text 但 editableElement 为空，设置初始文本
    if (this.text && !this.editableElement.innerHTML) {
      this.editableElement.innerHTML = this.text;
    }

    // 清理旧的事件监听器
    this.editableElement.removeEventListener('input', this.handleInput);

    // 使用 input 事件监听任何变化，不需要 blur 事件
    // 因为不会重新渲染，所以可以实时更新值
    if (!isReadonly) {
      this.editableElement.addEventListener('input', this.handleInput);
    }
  }

  private handleInput = () => {
    if (this.editableElement) {
      const html = this.editableElement.innerHTML;
      this.text = html;

      // 直接派发 textchange 事件，实时更新父组件的值
      this.dispatchEvent(
        new CustomEvent('textchange', {
          detail: { text: html },
          bubbles: true,
          composed: true,
        })
      );
    }
  };

  /**
   * 获取当前文本（HTML 格式）
   */
  getText(): string {
    const domText = this.editableElement?.innerHTML;
    return domText !== undefined && domText !== '' ? domText : this.text;
  }

  /**
   * 设置文本（HTML 格式）
   */
  setText(html: string): void {
    if (this.editableElement) {
      this.editableElement.innerHTML = html;
    }
  }

  render() {
    const isReadonly = this.readonly;
    const className = isReadonly
      ? 'quiz-question-description-readonly'
      : 'quiz-question-description-editable';

    return (
      <div className="quiz-question-description">
        <div
          className={className}
          ref={(el: HTMLElement) => {
            this.editableElement = el;

            // 首次同步：如果 state 有值且 DOM 为空，同步它
            if (el && this.text && el.innerHTML === '') {
              el.innerHTML = this.text;
            }

            this.setupEditableElement();
          }}
          contentEditable={!isReadonly}
          data-placeholder={L10nService.t.editor.descriptionPlaceholder}
        />
      </div>
    );
  }
}
